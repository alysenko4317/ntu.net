using System;

class KeyEventArgs : EventArgs
{
    public char KeyChar { get; set; }
}

class KeyEvent
{
    public event EventHandler<KeyEventArgs> KeyPress;  // використання стандартного типу делегату EventHandler

    public void OnKeyPress(char key)
    {
        KeyEventArgs e = new KeyEventArgs { KeyChar = key };
        KeyPress?.Invoke(this, e);
    }
}



/*
   Замикання (closures) - це концепція в програмуванні, яка визначає те, як функція зберігає доступ до змінних
   з оточуючого контексту, в якому вона була створена, навіть після того, як цей контекст вже закінчив свою роботу.

    Що дають замикання програмісту:

    1. **Збереження стану**:
       Замикання дозволяють функціям зберігати та використовувати стан змінних із зовнішнього контексту. Це особливо корисно,
       коли потрібно, щоб внутрішня функція могла зберігати значення або лічильники, які були оголошені поза нею.
           Приклад: лічильник кількості викликів функції або запам'ятовування попередніх результатів.

    2. **Інкапсуляція логіки**:
       Замикання дозволяють інкапсулювати частину логіки всередині функції, яка доступна тільки цій функції. Це дозволяє створювати 
       чисті, модульні рішення, де зовнішній код не має прямого доступу до змінних або функцій, що використовуються всередині замикання.
           Приклад: створення приватних змінних або методів, які можуть бути використані лише всередині певної функції.

    3. **Передача функцій як об'єктів**:
       Замикання дозволяють передавати функції разом з їхнім оточенням як об'єкти. Це дозволяє програмістам передавати 
       поведінку між різними частинами програми, створювати callback-функції та асинхронні операції.
           Приклад: асинхронні виклики або обробники подій, які зберігають стан під час виконання.

    4. **Функції вищого порядку**:
       Замикання дозволяють створювати функції, які повертають інші функції або приймають функції як аргументи. Це підвищує 
       гнучкість і можливості для створення більш універсального та функціонального коду.
           Приклад: лямбда-вирази, функції вищого порядку, каррінг (currying).

    5. **Гнучкість у створенні API**:
       Замикання дозволяють створювати більш гнучкі та прості API, де певні частини логіки можуть бути передані як параметри.
       Це робить API простішими у використанні та розширенні, оскільки замикання дають можливість уникнути необхідності 
       оголошення великої кількості проміжних змінних.
           Приклад: фреймворки або бібліотеки, що використовують лямбда-вирази для передачі поведінки.

    У підсумку, замикання дають програмістам можливість писати гнучкий, інкапсульований та ефективний код, дозволяючи функціям
    взаємодіяти з зовнішніми змінними та контекстами, що робить програму більш динамічною та зручною в підтримці.
*/


class KeyEventDemo
{
    static void Main()
    {
        int count = 0;
        ConsoleKeyInfo key;  // інформація про натиснуті клавіші

        KeyEvent kevt = new KeyEvent();

        kevt.KeyPress += OnKeyPress;

        kevt.KeyPress += (sender, e) => {
            Console.WriteLine("Натиснуто клавішу: " + e.KeyChar);
            count++;

            // використання змінної count у лямбда-виразі (sender, e) => { ... }
            // є прикладом замикання в C#
        };

        Console.WriteLine(
            "Будь ласка, натискайте клавіші. Для завершення введіть крапку '.'");

        do
        {
            key = Console.ReadKey();
            kevt.OnKeyPress(key.KeyChar);
        }
        while (key.KeyChar != '.');

        Console.WriteLine("Ви натиснули " + count + " клавіш.");
        Console.ReadKey();
    }

    
    static void OnKeyPress(object sender, KeyEventArgs e)   // Звичайний метод обробки події KeyPress
    {
        Console.WriteLine("Натиснуто клавішу: " + e.KeyChar);

        // Звичайний метод не має доступу до змінної count з методу Main (якщо вона не статична).
        // Це і демонструє, як замикання дозволяє лямбда-виразам працювати з локальними змінними
        // із зовнішнього контексту.
        //count++;
    }
}


